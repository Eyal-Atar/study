---
phase: 11-push-notifications
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/notifications/__init__.py
  - backend/notifications/routes.py
  - backend/notifications/scheduler.py
  - backend/server/database.py
  - backend/server/__init__.py
  - backend/users/schemas.py
  - backend/requirements.txt
autonomous: true
requirements: [NOTIF-01]
user_setup:
  - service: vapid-keys
    why: "VAPID keys authenticate the push server. Generated once per deployment."
    env_vars:
      - name: VAPID_PRIVATE_KEY
        source: "Generated by the plan script: python scripts/generate_vapid.py"
      - name: VAPID_PUBLIC_KEY
        source: "Generated by the plan script: python scripts/generate_vapid.py"
      - name: VAPID_CLAIMS_EMAIL
        source: "Set to your email address (e.g. admin@studyflow.app)"

must_haves:
  truths:
    - "Browser can subscribe to push notifications and the subscription is stored server-side"
    - "Backend sends a Web Push message that appears as an OS notification"
    - "Claude generates a WhatsApp-friend style motivational message before each notification is sent"
    - "Cron job reads upcoming schedule blocks per user and fires notifications at the user's chosen offset"
  artifacts:
    - path: "backend/notifications/routes.py"
      provides: "POST /push/subscribe endpoint stores PushSubscription JSON per user"
      exports: ["router"]
    - path: "backend/notifications/scheduler.py"
      provides: "APScheduler cron job â€” scans upcoming blocks, calls Claude, sends via pywebpush"
      min_lines: 60
    - path: "backend/server/database.py"
      provides: "Migration adding push_subscription, notif_timing, notif_per_task, notif_daily_summary columns to users table"
      contains: "push_subscription"
    - path: "backend/requirements.txt"
      provides: "pywebpush and apscheduler dependencies"
      contains: "pywebpush"
  key_links:
    - from: "backend/notifications/scheduler.py"
      to: "anthropic client"
      via: "Claude API call for WhatsApp-friend message"
      pattern: "anthropic|claude|messages\\.create"
    - from: "backend/notifications/scheduler.py"
      to: "pywebpush webpush()"
      via: "send push notification"
      pattern: "webpush\\("
    - from: "backend/notifications/routes.py"
      to: "users table push_subscription column"
      via: "UPDATE users SET push_subscription"
      pattern: "push_subscription"
    - from: "backend/server/__init__.py"
      to: "backend/notifications/routes.py"
      via: "app.include_router(notifications_router)"
      pattern: "notifications"
---

<objective>
Build the server-side push notification engine: DB migration for push preferences, VAPID Web Push backend with pywebpush, a POST /push/subscribe endpoint, and an APScheduler cron job that reads upcoming study blocks, generates a Claude "WhatsApp Friend" message, and fires the push notification.

Purpose: This is the NOTIF-01 backend â€” without it, no notifications can fire even if the frontend requests permission.
Output: backend/notifications/ domain module, updated requirements.txt, DB migration, scheduler wired into FastAPI startup.
</objective>

<execution_context>
@/Users/eyalatar/.claude/get-shit-done/workflows/execute-plan.md
@/Users/eyalatar/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/11-push-notifications/11-CONTEXT.md
@backend/server/database.py
@backend/server/__init__.py
@backend/users/schemas.py
@backend/requirements.txt
</context>

<tasks>

<task type="auto">
  <name>Task 1: DB migration, VAPID setup, and POST /push/subscribe endpoint</name>
  <files>
    backend/server/database.py,
    backend/notifications/__init__.py,
    backend/notifications/routes.py,
    backend/users/schemas.py,
    backend/requirements.txt,
    backend/server/__init__.py,
    scripts/generate_vapid.py
  </files>
  <action>
**Step 1 â€” Add dependencies to requirements.txt:**
```
pywebpush>=2.0.0
apscheduler>=3.10.0
```
Install them: `pip install pywebpush apscheduler` (run inside `.venv`).

**Step 2 â€” DB migration in `backend/server/database.py`:**
Inside the `init_db()` function, after the existing `block_columns` migration block, add:
```python
# Migrations: add push notification columns to users
user_columns = {row[1] for row in conn.execute("PRAGMA table_info(users)").fetchall()}
if "push_subscription" not in user_columns:
    conn.execute("ALTER TABLE users ADD COLUMN push_subscription TEXT")
if "notif_timing" not in user_columns:
    conn.execute("ALTER TABLE users ADD COLUMN notif_timing TEXT DEFAULT 'at_start'")
if "notif_per_task" not in user_columns:
    conn.execute("ALTER TABLE users ADD COLUMN notif_per_task INTEGER DEFAULT 1")
if "notif_daily_summary" not in user_columns:
    conn.execute("ALTER TABLE users ADD COLUMN notif_daily_summary INTEGER DEFAULT 0")
```

**Step 3 â€” Update `backend/users/schemas.py`:**
Add to `UserResponse` and `UserUpdate` models:
```python
push_subscription: Optional[str] = None
notif_timing: Optional[str] = 'at_start'
notif_per_task: Optional[int] = 1
notif_daily_summary: Optional[int] = 0
```

**Step 4 â€” Generate VAPID keys:**
Create `scripts/generate_vapid.py`:
```python
#!/usr/bin/env python3
"""Generate VAPID keys for Web Push. Run once and add output to .env"""
from pywebpush import Vapid

vapid = Vapid()
vapid.generate_keys()
private_key = vapid.private_pem().decode()
public_key = vapid.public_key.get_elliptic_curve_key_as_pem().decode()

# For web push, we need the URL-safe base64 uncompressed public key
import base64
from cryptography.hazmat.primitives.asymmetric.ec import EllipticCurvePublicKey
from cryptography.hazmat.primitives.serialization import Encoding, PublicFormat
pub_raw = vapid.public_key.get_elliptic_curve_key()
pub_bytes = pub_raw.public_bytes(Encoding.X962, PublicFormat.UncompressedPoint)
pub_b64 = base64.urlsafe_b64encode(pub_bytes).rstrip(b'=').decode()

print("Add to .env:")
print(f'VAPID_PRIVATE_KEY="{private_key.strip()}"')
print(f'VAPID_PUBLIC_KEY="{pub_b64}"')
print('VAPID_CLAIMS_EMAIL="admin@studyflow.app"')
```

Run it: `cd "/Users/eyalatar/Desktop/try /studyflow" && source .venv/bin/activate && python scripts/generate_vapid.py`
Copy the output lines into `backend/.env`.

Note: If the above pywebpush API doesn't match the installed version, use the simpler approach:
```python
from py_vapid import Vapid01
vapid = Vapid01.generate_keys()
# or use: from pywebpush import Vapid; ...
```
Adapt to what the installed version exports. Check with `python -c "import pywebpush; help(pywebpush)"`.

**Step 5 â€” Create `backend/notifications/__init__.py`:** Empty file.

**Step 6 â€” Create `backend/notifications/routes.py`:**
```python
"""Push notification subscription endpoints."""

from fastapi import APIRouter, Depends, HTTPException
from server.database import get_db
from auth.utils import get_current_user
import json
import os

router = APIRouter()

VAPID_PUBLIC_KEY = os.getenv("VAPID_PUBLIC_KEY", "")

@router.get("/push/vapid-public-key")
def get_vapid_key():
    """Return VAPID public key for client-side subscription."""
    if not VAPID_PUBLIC_KEY:
        raise HTTPException(status_code=503, detail="Push not configured")
    return {"key": VAPID_PUBLIC_KEY}

@router.post("/push/subscribe")
def subscribe(body: dict, current_user: dict = Depends(get_current_user)):
    """Store the PushSubscription JSON for this user."""
    subscription = body.get("subscription")
    if not subscription:
        raise HTTPException(status_code=400, detail="subscription required")
    db = get_db()
    try:
        db.execute(
            "UPDATE users SET push_subscription = ? WHERE id = ?",
            (json.dumps(subscription), current_user["id"])
        )
        db.commit()
    finally:
        db.close()
    return {"status": "subscribed"}

@router.delete("/push/subscribe")
def unsubscribe(current_user: dict = Depends(get_current_user)):
    """Clear the PushSubscription for this user (opt-out)."""
    db = get_db()
    try:
        db.execute("UPDATE users SET push_subscription = NULL WHERE id = ?", (current_user["id"],))
        db.commit()
    finally:
        db.close()
    return {"status": "unsubscribed"}
```

**Step 7 â€” Register router in `backend/server/__init__.py`:**
Import and include the notifications router alongside existing routers:
```python
from notifications.routes import router as notifications_router
app.include_router(notifications_router)
```
  </action>
  <verify>
```bash
cd "/Users/eyalatar/Desktop/try /studyflow" && source .venv/bin/activate
python -c "import pywebpush; import apscheduler; print('deps OK')"
python -c "from notifications.routes import router; print('router OK')"
python backend/run.py &
sleep 3
curl -s http://localhost:8000/push/vapid-public-key
pkill -f "python backend/run.py"
```
  </verify>
  <done>
`pywebpush` and `apscheduler` importable. `GET /push/vapid-public-key` returns `{"key": "..."}` (non-empty string). `POST /push/subscribe` returns 200 when called with a valid auth token and subscription body. DB has push_subscription column on users table.
  </done>
</task>

<task type="auto">
  <name>Task 2: APScheduler cron job with Claude "WhatsApp Friend" message generation</name>
  <files>backend/notifications/scheduler.py, backend/server/__init__.py</files>
  <action>
Create `backend/notifications/scheduler.py`:

```python
"""
Push notification scheduler.
Runs as a background task inside FastAPI using APScheduler.
Every minute: scans upcoming schedule_blocks, determines which users need a notification
based on their notif_timing offset, generates a Claude WhatsApp-friend message, and sends
it via Web Push using pywebpush.
"""

import json
import os
import logging
from datetime import datetime, timedelta, timezone

import anthropic
from apscheduler.schedulers.background import BackgroundScheduler
from pywebpush import webpush, WebPushException

from server.database import get_db

logger = logging.getLogger(__name__)

VAPID_PRIVATE_KEY = os.getenv("VAPID_PRIVATE_KEY", "")
VAPID_CLAIMS_EMAIL = os.getenv("VAPID_CLAIMS_EMAIL", "admin@studyflow.app")

TIMING_OFFSETS = {
    "at_start": 0,
    "15_before": 15,
    "30_before": 30,
}

_anthropic = anthropic.Anthropic()


def _generate_message(subject: str, task_title: str, minutes_until: int) -> str:
    """Call Claude to generate a WhatsApp-friend style motivational message."""
    try:
        prompt = (
            f"Write a very short, humorous, WhatsApp-style message reminding the user about "
            f"their upcoming study session for {task_title} ({subject}) in {minutes_until} minutes. "
            f"Use emojis. Sound like a funny, slightly sarcastic friend, NOT a robot app. "
            f"Keep it under 120 characters. One sentence only."
        )
        msg = _anthropic.messages.create(
            model="claude-3-haiku-20240307",
            max_tokens=80,
            messages=[{"role": "user", "content": prompt}]
        )
        return msg.content[0].text.strip()
    except Exception as e:
        logger.warning(f"Claude message generation failed: {e}")
        return f"Hey! {task_title} in {minutes_until} min. You got this ðŸ’ª"


def _send_push(subscription_json: str, title: str, body: str) -> bool:
    """Send a Web Push notification to the given subscription endpoint."""
    if not VAPID_PRIVATE_KEY:
        logger.warning("VAPID_PRIVATE_KEY not set â€” skipping push send")
        return False
    try:
        subscription_info = json.loads(subscription_json)
        webpush(
            subscription_info=subscription_info,
            data=json.dumps({"title": title, "body": body, "url": "/"}),
            vapid_private_key=VAPID_PRIVATE_KEY,
            vapid_claims={"sub": f"mailto:{VAPID_CLAIMS_EMAIL}"}
        )
        return True
    except WebPushException as e:
        logger.warning(f"WebPush failed: {e}")
        return False
    except Exception as e:
        logger.error(f"Push send error: {e}")
        return False


def _check_and_send_notifications():
    """
    Called by scheduler every minute.
    For each user with a push_subscription and notif_per_task=1,
    find schedule_blocks starting within the next [offset+1, offset] minutes window,
    generate a Claude message, and send a push notification.
    """
    now_utc = datetime.now(timezone.utc)
    db = get_db()
    try:
        users = db.execute(
            """SELECT id, push_subscription, notif_timing, notif_per_task, notif_daily_summary
               FROM users
               WHERE push_subscription IS NOT NULL AND notif_per_task = 1"""
        ).fetchall()

        for user in users:
            user = dict(user)
            offset_min = TIMING_OFFSETS.get(user["notif_timing"] or "at_start", 0)
            # Target: blocks starting between (now + offset) and (now + offset + 1 min)
            target_start = now_utc + timedelta(minutes=offset_min)
            window_start = target_start.strftime("%Y-%m-%dT%H:%M")
            window_end = (target_start + timedelta(minutes=1)).strftime("%Y-%m-%dT%H:%M")

            blocks = db.execute(
                """SELECT task_title, exam_name, start_time FROM schedule_blocks
                   WHERE user_id = ? AND block_type = 'study'
                   AND completed = 0
                   AND start_time >= ? AND start_time < ?""",
                (user["id"], window_start, window_end)
            ).fetchall()

            for block in blocks:
                block = dict(block)
                task_title = block["task_title"] or "Study session"
                subject = block["exam_name"] or "your exam"
                body = _generate_message(subject, task_title, offset_min if offset_min > 0 else 0)
                title = "StudyFlow ðŸ“š"
                success = _send_push(user["push_subscription"], title, body)
                if success:
                    logger.info(f"Push sent to user {user['id']} for block '{task_title}'")

    except Exception as e:
        logger.error(f"Notification scheduler error: {e}")
    finally:
        db.close()


def start_scheduler() -> BackgroundScheduler:
    """Create, configure, and start the APScheduler background scheduler."""
    scheduler = BackgroundScheduler()
    scheduler.add_job(
        _check_and_send_notifications,
        trigger="interval",
        minutes=1,
        id="push_notification_job",
        replace_existing=True
    )
    scheduler.start()
    logger.info("[Scheduler] Push notification scheduler started")
    return scheduler
```

**Wire into FastAPI startup in `backend/server/__init__.py`:**

After the existing router includes, add:
```python
from notifications.scheduler import start_scheduler

_scheduler = None

@app.on_event("startup")
async def on_startup():
    global _scheduler
    _scheduler = start_scheduler()

@app.on_event("shutdown")
async def on_shutdown():
    global _scheduler
    if _scheduler and _scheduler.running:
        _scheduler.shutdown()
```

Note: `on_event("startup")` is the FastAPI lifespan pattern for this codebase. Check if the existing `__init__.py` already uses a lifespan context manager or startup events. If it uses `@app.on_event`, match that pattern. If it uses `@asynccontextmanager` lifespan, add the scheduler start/stop inside the lifespan block instead.

The scheduler runs every 1 minute and fires push notifications for study blocks matching the timing window. No notification will fire unless `VAPID_PRIVATE_KEY` is set in `.env`.
  </action>
  <verify>
```bash
cd "/Users/eyalatar/Desktop/try /studyflow" && source .venv/bin/activate
python -c "from notifications.scheduler import start_scheduler, _check_and_send_notifications; print('scheduler module OK')"
python backend/run.py &
sleep 3
curl -s http://localhost:8000/docs | grep -q "push" && echo "push routes registered"
pkill -f "python backend/run.py"
```
  </verify>
  <done>
`notifications/scheduler.py` imports without error. FastAPI starts without crashing (scheduler starts in background). Server logs show "[Scheduler] Push notification scheduler started". `/docs` shows push endpoints. `_check_and_send_notifications()` can be called without error (even if no users have subscriptions).
  </done>
</task>

</tasks>

<verification>
1. `pip install pywebpush apscheduler` completes without errors
2. `GET /push/vapid-public-key` returns `{"key": "..."}` with non-empty key
3. `POST /push/subscribe` with valid auth + subscription JSON returns `{"status": "subscribed"}`
4. Server starts and logs show scheduler initialized
5. `backend/server/database.py` migration adds push_subscription column â€” verify with: `python3 -c "from server.database import init_db; init_db()" && sqlite3 studyflow.db "PRAGMA table_info(users);"` shows push_subscription column
</verification>

<success_criteria>
- VAPID keys generated and in .env
- Browser can subscribe and subscription is persisted to DB
- Scheduler runs every minute; for users with push_subscription it calls Claude and fires webpush
- Claude uses WhatsApp-friend persona per CONTEXT.md locked decision
- FastAPI starts/stops scheduler cleanly
</success_criteria>

<output>
After completion, create `.planning/phases/11-push-notifications/11-02-SUMMARY.md`
</output>
