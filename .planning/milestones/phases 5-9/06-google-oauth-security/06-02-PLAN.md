---
phase: 06-google-oauth-security
plan: 02
type: execute
wave: 2
depends_on: [06-01]
files_modified: [backend/auth/oauth_config.py, backend/auth/routes.py, .env]
autonomous: true
requirements: [AUTH-01]
---

<objective>
Implement Google OAuth 2.0 backend routes for signing in, linking accounts, and creating new accounts from Google profile data.

Purpose: Provide the server-side logic for Google Sign-In.
Output: Working OAuth login and callback routes.
</objective>

<execution_context>
@/Users/eyalatar/.gemini/get-shit-done/workflows/execute-plan.md
@/Users/eyalatar/.gemini/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/research/06-google-oauth-research.md
@backend/auth/routes.py
@backend/auth/utils.py
@backend/server/database.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Authlib Configuration</name>
  <files>backend/auth/oauth_config.py, .env</files>
  <action>
    - Create `backend/auth/oauth_config.py` using the `Authlib` patterns from research.
    - Add `GOOGLE_CLIENT_ID` and `GOOGLE_CLIENT_SECRET` placeholders to `.env`.
    - Configure the `google` provider with `server_metadata_url` for OpenID Connect discovery.
    - Set scopes to `openid email profile`.
  </action>
  <verify>`backend/auth/oauth_config.py` exists and is correctly configured.</verify>
  <done>Authlib is ready for Google OAuth.</done>
</task>

<task type="auto">
  <name>Task 2: Implement OAuth Routes</name>
  <files>backend/auth/routes.py</files>
  <action>
    - Import `oauth` from `oauth_config.py` in `backend/auth/routes.py`.
    - Implement `GET /auth/google/login`:
      - Initiates the OAuth flow and redirects to Google.
    - Implement `GET /auth/google/callback`:
      - Handles the token exchange and state validation.
      - Extracts user info (`sub`, `email`, `name`) from the `userinfo` claim.
      - Implements the linking/creation logic:
        1. Try finding user by `google_id`.
        2. If not found, try finding user by `email`.
           - If found: link account (set `google_id`, `google_linked=1`), disable password login for this account.
           - If not found: create new user from Google profile.
        3. Set the `session_token` cookie for the user.
        4. Redirect to:
           - `/onboarding` (first-time Google users).
           - `/dashboard` (returning users).
  </action>
  <verify>Routes exist and handle the OAuth flow correctly up to the redirection point.</verify>
  <done>OAuth routes are implemented and functional.</done>
</task>

<task type="auto">
  <name>Task 3: Refine Existing Login for Linked Accounts</name>
  <files>backend/auth/routes.py</files>
  <action>
    - Update the existing email/password `login` route to check if the account is `google_linked`.
    - If `google_linked` is true, return a 403 error: "This account uses Google Sign-In. Please use the 'Sign in with Google' button."
  </action>
  <verify>Existing login correctly identifies and blocks linked accounts.</verify>
  <done>Linked accounts are protected from password login.</done>
</task>

</tasks>

<verification>
- Verify `GET /auth/google/login` redirects to Google.
- Verify `GET /auth/google/callback` creates/links users and sets cookies.
- Verify existing password login is disabled for Google-linked accounts.
</verification>

<success_criteria>
- Backend supports full OAuth 2.0 redirect-based flow.
- Accounts are correctly auto-linked or auto-created based on email/Google ID.
- First-time users are redirected to onboarding.
</success_criteria>

<output>
After completion, create `.planning/phases/06-google-oauth-security/06-02-SUMMARY.md`
</output>
