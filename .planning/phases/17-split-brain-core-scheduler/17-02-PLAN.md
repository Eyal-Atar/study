---
phase: 17-split-brain-core-scheduler
plan: 02
type: execute
wave: 2
depends_on:
  - 17-01
files_modified:
  - backend/brain/exam_brain.py
  - backend/brain/routes.py
autonomous: true
requirements:
  - SB-01
  - SB-04

must_haves:
  truths:
    - "Auditor processes ALL exams in a single AI call with full extracted text"
    - "Auditor returns tasks with focus_score and dependency_id for each task"
    - "Auditor detects gaps (syllabus topics without matching summary content)"
    - "Auditor output is stored in DB as auditor_draft for persistence"
    - "POST /brain/generate-roadmap returns Auditor output (tasks + gaps + topic_map) instead of a schedule"
    - "GET /brain/auditor-draft retrieves stored Auditor output"
  artifacts:
    - path: "backend/brain/exam_brain.py"
      provides: "call_split_brain() and _call_auditor() methods"
      contains: "call_split_brain"
    - path: "backend/brain/routes.py"
      provides: "Updated generate-roadmap route returning Auditor output; new auditor-draft GET route"
      contains: "auditor-draft"
  key_links:
    - from: "backend/brain/exam_brain.py"
      to: "backend/server/database.py"
      via: "reads extracted_text from exam_files"
      pattern: "extracted_text"
    - from: "backend/brain/routes.py"
      to: "backend/brain/exam_brain.py"
      via: "calls call_split_brain()"
      pattern: "call_split_brain"
---

<objective>
Implement the Auditor (API Call 1) — the content analysis brain that processes all exams in one call and returns tasks with focus scores, dependencies, and detected gaps.

Purpose: The Auditor replaces the old per-exam loop with a single intelligent call that sees the full picture across all exams simultaneously. This is the first of two AI calls in the split-brain architecture.
Output: Working Auditor call with API routes for triggering and fetching results.
</objective>

<execution_context>
@/Users/eyalatar/.claude/get-shit-done/workflows/execute-plan.md
@/Users/eyalatar/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/17-split-brain-core-scheduler/17-RESEARCH.md
@.planning/phases/17-split-brain-core-scheduler/17-01-SUMMARY.md
@backend/brain/exam_brain.py
@backend/brain/routes.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement Auditor call in ExamBrain</name>
  <files>backend/brain/exam_brain.py</files>
  <action>
Replace (or refactor alongside) the existing `analyze_all_exams()` method with a new split-brain approach:

1. **Add `_build_all_exam_context(self)` method:** Concatenates all exams and their `extracted_text` from DB into one string. For each exam, include header with exam name, subject, exam_date, then each file's extracted_text grouped by file_type. Fallback to `parsed_context` if no `extracted_text` exists (legacy users). Enforce 700K character limit (safety margin under Haiku's 200K token input). Truncate proportionally if exceeded. Use the exact pattern from 17-RESEARCH.md "Auditor Context Assembly" code example.

2. **Add `_build_auditor_prompt(self, all_exam_context, total_hours)` method:** Build the Auditor system+user prompt. Use the prompt template from 17-RESEARCH.md. The prompt must:
   - Accept all exam materials concatenated
   - Instruct Claude to map syllabus topics, detect gaps, decompose into tasks
   - Each task gets: exam_id, title, topic, estimated_hours (0.5-3.0), focus_score (1-10), dependency_id (null or index), sort_order
   - Return JSON with `tasks`, `gaps`, `topic_map` keys
   - Include "RETURN ONLY VALID JSON" instruction in system message

3. **Add `async call_split_brain(self)` method:**
   - Calls `_build_all_exam_context()` to get concatenated text
   - Computes total available hours from all exams
   - Calls Claude Haiku via existing `self.client.messages.create()` pattern (same model: `claude-3-haiku-20240307`)
   - Parses JSON response using existing fence-stripping logic (lines ~98-105 in current exam_brain.py). Add fallback: if `json.loads()` fails, search for first `[` or `{` character and try parsing from there.
   - Returns dict: `{"tasks": [...], "gaps": [...], "topic_map": {...}}`
   - Does NOT call Strategist — returns Auditor output only

4. **Keep `analyze_all_exams()` intact** for now (backward compatibility). The route will switch to calling `call_split_brain()` instead.

Important: Use `claude-3-haiku-20240307` model per locked decision. No new API keys.
  </action>
  <verify>
Add a temporary test in the route or run manually:
```python
brain = ExamBrain(user_id, db)
result = await brain.call_split_brain()
print(json.dumps(result, indent=2))
```
Verify result has `tasks` (list of dicts with focus_score), `gaps` (list), `topic_map` (dict).
  </verify>
  <done>ExamBrain has call_split_brain() that processes all exams in one Auditor call and returns structured JSON with tasks, gaps, and topic_map.</done>
</task>

<task type="auto">
  <name>Task 2: Update brain routes for Auditor flow</name>
  <files>backend/brain/routes.py</files>
  <action>
1. **Modify `POST /brain/generate-roadmap`:** Instead of calling `analyze_all_exams()` and then `generate_multi_exam_schedule()`, call `brain.call_split_brain()`. Store the result as JSON in `exams.auditor_draft` column (for each exam, store the full Auditor output so the review page can fetch it). Return the Auditor output to the frontend: `{"status": "auditor_complete", "tasks": [...], "gaps": [...], "topic_map": {...}}`. Do NOT generate a schedule yet.

2. **Add `GET /brain/auditor-draft`:** Fetches the most recent `auditor_draft` from the `exams` table for the authenticated user. Returns the stored JSON. This allows the intermediate review page to reload without losing state (per Research anti-pattern guidance).

3. **Preserve the existing `POST /brain/regenerate-schedule`** route unchanged — it's used for manual schedule regeneration from existing DB tasks, not for the split-brain flow.

4. Error handling: If the Auditor call fails (API error, JSON parse failure), return a clear error response `{"status": "error", "message": "..."}` with HTTP 500. Log the full error server-side.

Important: The `approve-and-schedule` route will be added in Plan 04 (Strategist). This plan only handles the Auditor half of the flow.
  </action>
  <verify>
Using curl or the frontend:
```bash
curl -X POST http://localhost:8000/brain/generate-roadmap -H "Authorization: Bearer $TOKEN"
```
Response should contain `{"status": "auditor_complete", "tasks": [...], "gaps": [...], "topic_map": {...}}`.

Then:
```bash
curl http://localhost:8000/brain/auditor-draft -H "Authorization: Bearer $TOKEN"
```
Should return the same stored Auditor output.
  </verify>
  <done>generate-roadmap returns Auditor output. auditor-draft endpoint serves stored output. No schedule is generated at this stage.</done>
</task>

</tasks>

<verification>
1. POST /brain/generate-roadmap returns Auditor JSON (not a schedule)
2. Tasks in response have focus_score and dependency_id fields
3. Gaps array lists topics in syllabus without summary coverage
4. GET /brain/auditor-draft returns same stored output
5. Existing regenerate-schedule route still works
6. API errors are handled gracefully (not silent 200 with empty data)
</verification>

<success_criteria>
- Single Auditor call processes all exams simultaneously
- Response includes tasks with focus_score (1-10) and dependency_id
- Gap detection identifies syllabus topics missing from summaries
- Auditor output persisted in DB for review page access
- All routes return proper error responses on failure
</success_criteria>

<output>
After completion, create `.planning/phases/17-split-brain-core-scheduler/17-02-SUMMARY.md`
</output>
