# Plan: Phase 17 - AI Context Optimization, Token Efficiency, and Constraint-Aware Scheduling

**Goal:** Decouple AI task decomposition from mathematical time allocation. The AI becomes a Strategist (logic), and Python becomes the Scheduler (math).

---

## Step 1: Database Migrations & Schema Refinement
- **Task:** Update `exams` and `users` tables to support context-aware scheduling and flexible breaks.
- **File:** `backend/server/database.py`
- **Logic:**
    - `ALTER TABLE exams ADD COLUMN parsed_context TEXT;` (Stores summarized JSON topics).
    - `ALTER TABLE users ADD COLUMN fixed_breaks TEXT;` (JSON string: `[{"name": "Lunch", "start": "13:00", "end": "14:00", "days": [0,1,2,3,4,5,6]}]`).
    - `ALTER TABLE schedule_blocks ADD COLUMN is_split INTEGER DEFAULT 0;`
    - `ALTER TABLE schedule_blocks ADD COLUMN part_number INTEGER DEFAULT 1;`
    - `ALTER TABLE schedule_blocks ADD COLUMN total_parts INTEGER DEFAULT 1;`

## Step 2: Context Optimization (The "Parser-First" Pipeline)
- **Task:** Reuse `syllabus_parser.py` to extract syllabus context upon upload and cache it.
- **Files:** `backend/brain/syllabus_parser.py`, `backend/exams/routes.py`
- **Logic:**
    - Update `extract_text_from_pdf` in `syllabus_parser.py` to limit reading to the **first 5 pages** for efficiency.
    - In `routes.py:upload_exam_file`, after saving the PDF, call `extract_tasks_from_pdf`.
    - Instead of just returning tasks, save the **summarized pedagogical context** (topics, intensity, structure) into `exams.parsed_context`.
    - **Hybrid Logic:** If an exam has no files, `ExamBrain` should generate tasks based on the `subject` and `name` using its internal knowledge.

## Step 3: ExamBrain Refactor (The "Strategist")
- **Task:** Strip date logic and enforce a pure prioritized queue output.
- **File:** `backend/brain/exam_brain.py`
- **Logic:**
    - Refactor `_build_calendar_prompt`:
        - **FORBID** dates or `day_date` in the output.
        - Output JSON: `[{"title": str, "estimated_hours": float, "sort_order": int, "priority": int}]`.
        - Enforce "Single Focus" (one exam per study phase) and "Simulation-First" logic.
    - **Zero-Data prompt:** Add a specific instruction: "If no file content is provided, use your expert knowledge of [Subject Name] to decompose the study requirements into a logically ordered sequence of tasks."

## Step 4: Scheduler Rewriting (The "Executor")
- **Task:** Implement "Available Time Window" logic with deterministic Greedy-Fill.
- **File:** `backend/brain/scheduler.py`
- **Logic:**
    - **Window Calculation:** For each day, generate a list of `WiredWindow` objects by:
        1. Starting with the `wake_up_time` to `sleep_time` range.
        2. Subtracting `fixed_breaks` (filtered by day of week).
        3. Subtracting `hobby_name` time slot.
    - **Deterministic Greedy-Fill:**
        - Iterate through the AI's ordered task list.
        - "Pour" task hours into the `WiredWindow` array.
        - **Automatic Splitting:** If a task (e.g., 3h) hits a window boundary (e.g., only 1h left before Lunch), split it into two `ScheduleBlock` entries.
        - **Part Marking:** Set `is_split=1`, `part_number=X`, and `total_parts=Y` for these blocks.

## Step 5: Frontend Sync & Verification
- **Task:** Ensure UI handles part numbering and valid schedules.
- **Validation:**
    - **Math Check:** Sum of `estimated_hours` in `ScheduleBlock` for Task ID 123 must equal `estimated_hours` from `ExamBrain`.
    - **Visual Check:** Verify "Task Title (Part 1/2)" appears in the roadmap for split blocks.
    - **Boundary Check:** Verify no study block overlaps with a fixed break or sleep time.

---

## Success Criteria
1. AI output is date-agnostic JSON (shorter tokens, no hallucinations).
2. Schedules strictly respect user-defined breaks and waking hours.
3. Users get a valid roadmap even if they upload 0 files.
