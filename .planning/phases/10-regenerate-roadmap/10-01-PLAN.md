---
phase: 10-regenerate-roadmap
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/server/database.py
  - backend/tasks/routes.py
  - backend/tasks/schemas.py
  - backend/brain/routes.py
  - backend/brain/schemas.py
autonomous: true
requirements: [BRAIN-01, BRAIN-02, BRAIN-03]

must_haves:
  truths:
    - "schedule_blocks table has an is_manually_edited column (1 = manual, 0 = auto)"
    - "PATCH /tasks/block/{id} sets is_manually_edited=1 on any time/title update"
    - "POST /regenerate-delta endpoint exists, accepts {reason: string}, returns {reasoning, updated_blocks, schedule}"
    - "Regenerate endpoint builds compressed snapshot of next 14 days in pipe-delimited format"
    - "AI delta response is parsed and only FLX+A blocks are surgically updated"
    - "FIX blocks (exams/classes) and M-flagged blocks are never touched by regeneration"
  artifacts:
    - path: "backend/server/database.py"
      provides: "is_manually_edited column migration for schedule_blocks"
      contains: "is_manually_edited"
    - path: "backend/tasks/routes.py"
      provides: "PATCH endpoint sets is_manually_edited=1 on time/title update"
      contains: "is_manually_edited"
    - path: "backend/brain/routes.py"
      provides: "POST /regenerate-delta endpoint with delta AI logic"
      exports: ["regenerate_delta"]
    - path: "backend/brain/schemas.py"
      provides: "RegenerateDeltaRequest schema"
      contains: "RegenerateDeltaRequest"
  key_links:
    - from: "backend/brain/routes.py /regenerate-delta"
      to: "Anthropic Claude API"
      via: "compressed snapshot prompt"
      pattern: "regenerate.delta|pipe.*delimited"
    - from: "backend/brain/routes.py"
      to: "backend/server/database.py schedule_blocks"
      via: "surgical UPDATE WHERE id = ? AND is_manually_edited = 0"
      pattern: "UPDATE schedule_blocks.*is_manually_edited"
---

<objective>
Add the is_manually_edited flag to the database and implement the token-efficient delta regeneration backend endpoint.

Purpose: The AI regeneration system needs to distinguish manually-edited blocks from auto-generated ones so it never overwrites the user's own adjustments. The /regenerate-delta endpoint produces only the changed task slots, not a full schedule rebuild.

Output: DB migration, updated PATCH endpoint, new POST /regenerate-delta route, updated schemas.
</objective>

<execution_context>
@/Users/eyalatar/.claude/get-shit-done/workflows/execute-plan.md
@/Users/eyalatar/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-regenerate-roadmap/10-CONTEXT.md
@backend/server/database.py
@backend/tasks/routes.py
@backend/tasks/schemas.py
@backend/brain/routes.py
@backend/brain/schemas.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: DB migration + mark manual edits in PATCH endpoint</name>
  <files>
    backend/server/database.py
    backend/tasks/routes.py
    backend/tasks/schemas.py
  </files>
  <action>
**backend/server/database.py — add migration for is_manually_edited column:**

In the `init_db()` function, inside the block_columns migration section (after the existing `if "task_title" not in block_columns` check), add:

```python
if "is_manually_edited" not in block_columns:
    conn.execute("ALTER TABLE schedule_blocks ADD COLUMN is_manually_edited INTEGER DEFAULT 0")
```

This flag distinguishes blocks the user has manually moved/resized (Status `M`) from auto-generated blocks (Status `A`). Any block with is_manually_edited=1 must never be overwritten by the AI delta regeneration.

**backend/tasks/routes.py — set is_manually_edited=1 on time or title updates:**

In the `update_block()` function (PATCH /tasks/block/{block_id}), after the `if body.is_delayed is not None:` block, add:

```python
# Mark as manually edited if the user changed time or title
if body.start_time is not None or body.end_time is not None or body.task_title is not None:
    updates.append("is_manually_edited = 1")
```

This must be added BEFORE the `if not updates: return` early exit, within the `updates` construction block. The flag is permanent — once manually edited, a block keeps this status.

**backend/tasks/schemas.py — add is_manually_edited to BlockUpdate:**

Add `is_manually_edited: Optional[bool] = None` field to the `BlockUpdate` class so the schema stays correct. Do NOT allow the frontend to set this to 0 — the backend sets it automatically.

Note: Do NOT add is_manually_edited to the auto-setting path in update_block; the backend derives it from whether time/title fields were updated.
  </action>
  <verify>
    Start the server: `cd "/Users/eyalatar/Desktop/try /studyflow/backend" && python -m uvicorn server:app --port 8001 --reload &amp; sleep 3`
    Run migration check: `curl -s http://localhost:8001/health` (or restart server) and inspect database.py loads without error.
    Check column exists: `sqlite3 "/Users/eyalatar/Desktop/try /studyflow/studyflow.db" "PRAGMA table_info(schedule_blocks);" | grep manually`
    Expected output: line containing `is_manually_edited`
    Kill test server: `pkill -f "port 8001" 2>/dev/null || true`
  </verify>
  <done>
    - schedule_blocks table has is_manually_edited column (INTEGER DEFAULT 0)
    - PATCH /tasks/block/{id} sets is_manually_edited=1 when start_time, end_time, or task_title is provided
    - No Python syntax errors; server starts cleanly
  </done>
</task>

<task type="auto">
  <name>Task 2: POST /regenerate-delta endpoint with compressed AI delta logic</name>
  <files>
    backend/brain/routes.py
    backend/brain/schemas.py
  </files>
  <action>
**backend/brain/schemas.py — add RegenerateDeltaRequest schema:**

```python
class RegenerateDeltaRequest(BaseModel):
    reason: str  # Natural language reason, e.g. "I moved my exam to Friday"
```

**backend/brain/routes.py — add POST /regenerate-delta endpoint:**

Import `RegenerateDeltaRequest` from schemas at the top of the file.

Add the following route after the existing `/regenerate-schedule` route:

```python
@router.post("/regenerate-delta")
async def regenerate_delta(body: RegenerateDeltaRequest, current_user: dict = Depends(get_current_user)):
    """Token-efficient delta schedule regeneration.

    Fetches next 14 days of schedule blocks, builds a compressed pipe-delimited
    snapshot, sends to Claude with a delta-only system prompt, parses the response,
    and surgically updates ONLY auto-generated FLX blocks that the AI says moved.
    FIX blocks (exams) and manually-edited blocks (is_manually_edited=1) are never touched.
    """
    import anthropic
    import re
    from datetime import datetime, timedelta, timezone

    api_key = os.environ.get("ANTHROPIC_API_KEY")
    if not api_key:
        raise HTTPException(status_code=400, detail="AI features require an API key")

    user_id = current_user["id"]
    db = get_db()

    # 1. Fetch next 14 days of schedule blocks
    now_utc = datetime.now(timezone.utc)
    tz_offset = current_user.get("timezone_offset", 0) or 0
    local_now = now_utc - timedelta(minutes=tz_offset)
    today_str = local_now.strftime("%Y-%m-%d")
    window_end_str = (local_now + timedelta(days=14)).strftime("%Y-%m-%d")

    blocks_rows = db.execute(
        """SELECT sb.id, sb.task_id, sb.block_type, sb.is_manually_edited,
                  sb.start_time, sb.end_time, sb.day_date, sb.completed,
                  e.status as exam_status
           FROM schedule_blocks sb
           LEFT JOIN exams e ON sb.exam_id = e.id
           WHERE sb.user_id = ?
             AND sb.day_date >= ? AND sb.day_date <= ?
             AND sb.completed = 0
           ORDER BY sb.day_date, sb.start_time""",
        (user_id, today_str, window_end_str)
    ).fetchall()

    blocks = [dict(b) for b in blocks_rows]

    if not blocks:
        db.close()
        raise HTTPException(status_code=400, detail="No upcoming schedule blocks found. Generate a roadmap first.")

    # 2. Build compressed pipe-delimited snapshot
    # Format: [BlockID]|[Type]|[Status]|[Day][StartTime]-[EndTime]
    # Type: FIX = exam/class block (never move), FLX = study/hobby (can move)
    # Status: M = manually edited (preserve), A = auto-generated (AI can move)
    snapshot_lines = []
    for b in blocks:
        block_type_flag = "FIX" if b["block_type"] == "study" and b.get("exam_status") == "upcoming" and b["task_id"] is None else "FLX"
        # Exams are FIX; hobby blocks and study sessions are FLX
        if b["block_type"] in ("break",):
            continue  # Skip break blocks entirely
        if b["block_type"] == "hobby":
            block_type_flag = "FLX"
        else:
            # Study block: FIX only if it's an exam-day marker (no task_id and exam_status=upcoming)
            block_type_flag = "FLX"  # All study blocks in this system are flexible

        status_flag = "M" if b["is_manually_edited"] else "A"

        # Parse day and time from start_time (ISO format: YYYY-MM-DD or YYYY-MM-DDTHH:MM:SS)
        start_str = b["start_time"]
        end_str = b["end_time"]
        try:
            start_dt = datetime.fromisoformat(start_str)
            end_dt = datetime.fromisoformat(end_str)
            day_part = start_dt.strftime("%a")  # Mon, Tue, etc.
            start_time_part = start_dt.strftime("%H:%M")
            end_time_part = end_dt.strftime("%H:%M")
        except (ValueError, TypeError):
            day_part = b.get("day_date", "")
            start_time_part = start_str[-8:-3] if len(start_str) >= 8 else start_str
            end_time_part = end_str[-8:-3] if len(end_str) >= 8 else end_str

        snapshot_lines.append(
            f"{b['id']}|{block_type_flag}|{status_flag}|{day_part}{start_time_part}-{end_time_part}"
        )

    snapshot = ";".join(snapshot_lines)

    # 3. Build AI prompt
    system_prompt = """You are a schedule optimizer. You receive a compressed snapshot of a student's upcoming schedule and a reason for a constraint change. Your job is to output ONLY the delta — the blocks that need to move.

HARD RULES:
1. NEVER change blocks with Status M (manually edited by user). Skip them entirely.
2. NEVER change blocks with Type FIX (fixed events like exams). Skip them entirely.
3. Only output blocks that ACTUALLY need to move. Do NOT output unchanged blocks.
4. Do NOT output full JSON. Use the exact response format below.

Response format (first line is reasoning, then one delta line per moved block):
Reasoning: [1 sentence explaining the shift]
[BlockID]:[NewDay][NewStart]-[NewEnd]

Example:
Reasoning: Moved study sessions earlier to accommodate the new exam date.
42:Mon09:00-11:00
57:Tue14:00-16:00

If no blocks need to move, respond with:
Reasoning: No changes needed — the current schedule already accommodates the constraint.
"""

    user_message = f"""Schedule snapshot (next 14 days):
{snapshot}

Reason for regeneration: {body.reason}

Output the delta using the format above. Remember: only output blocks that ACTUALLY need to move."""

    # 4. Call Claude API
    client = anthropic.Anthropic(api_key=api_key)
    try:
        message = client.messages.create(
            model="claude-sonnet-4-5-20250929",
            max_tokens=1000,
            system=system_prompt,
            messages=[{"role": "user", "content": user_message}]
        )
        response_text = message.content[0].text.strip()
    except Exception as e:
        db.close()
        raise HTTPException(status_code=500, detail=f"AI call failed: {str(e)}")

    # 5. Parse delta response
    lines = response_text.strip().split("\n")
    reasoning = ""
    delta_updates = []

    for line in lines:
        line = line.strip()
        if line.startswith("Reasoning:"):
            reasoning = line[len("Reasoning:"):].strip()
        elif re.match(r"^\d+:", line):
            # Parse: BlockID:DayHH:MM-HH:MM
            match = re.match(r"^(\d+):([A-Za-z]{3})(\d{2}:\d{2})-(\d{2}:\d{2})$", line)
            if match:
                block_id = int(match.group(1))
                day_abbr = match.group(2)
                new_start_time = match.group(3)
                new_end_time = match.group(4)
                delta_updates.append({
                    "block_id": block_id,
                    "day_abbr": day_abbr,
                    "new_start_time": new_start_time,
                    "new_end_time": new_end_time
                })

    # 6. Build a day abbreviation -> date mapping for the next 14 days
    # We need to convert day abbreviations back to actual dates
    day_to_date = {}
    for i in range(15):
        d = local_now + timedelta(days=i)
        abbr = d.strftime("%a")
        if abbr not in day_to_date:
            day_to_date[abbr] = d.strftime("%Y-%m-%d")

    # 7. Build a set of valid block IDs (FLX + A only) from our snapshot
    valid_update_ids = {
        b["id"] for b in blocks
        if not b["is_manually_edited"]  # Status A only
        # All blocks in our snapshot are FLX (we excluded FIX above)
    }

    # 8. Surgically update ONLY allowed blocks
    updated_count = 0
    for delta in delta_updates:
        block_id = delta["block_id"]

        # Safety check: skip if not in our valid set
        if block_id not in valid_update_ids:
            continue

        new_date = day_to_date.get(delta["day_abbr"])
        if not new_date:
            continue

        new_start_iso = f"{new_date}T{delta['new_start_time']}:00"
        new_end_iso = f"{new_date}T{delta['new_end_time']}:00"

        db.execute(
            """UPDATE schedule_blocks
               SET start_time = ?, end_time = ?, day_date = ?
               WHERE id = ? AND user_id = ? AND is_manually_edited = 0""",
            (new_start_iso, new_end_iso, new_date, block_id, user_id)
        )
        # Sync the task's day_date too if applicable
        block_row = db.execute(
            "SELECT task_id FROM schedule_blocks WHERE id = ? AND user_id = ?",
            (block_id, user_id)
        ).fetchone()
        if block_row and block_row["task_id"]:
            db.execute(
                "UPDATE tasks SET day_date = ? WHERE id = ? AND user_id = ?",
                (new_date, block_row["task_id"], user_id)
            )
        updated_count += 1

    db.commit()

    # 9. Return updated schedule for frontend to re-render
    schedule_rows = db.execute(
        "SELECT * FROM schedule_blocks WHERE user_id = ? ORDER BY day_date, start_time",
        (user_id,)
    ).fetchall()
    schedule = [dict(s) for s in schedule_rows]

    tasks_rows = db.execute(
        "SELECT * FROM tasks WHERE user_id = ? AND status != 'done' ORDER BY day_date, sort_order",
        (user_id,)
    ).fetchall()
    tasks = [dict(t) for t in tasks_rows]

    db.close()

    return {
        "reasoning": reasoning,
        "blocks_updated": updated_count,
        "tasks": tasks,
        "schedule": schedule,
    }
```

Important implementation notes:
- The WHERE clause `AND is_manually_edited = 0` in the UPDATE is a safety double-check even after the Python-level `valid_update_ids` filtering.
- If delta_updates is empty (no changes needed), the endpoint still returns the current schedule (no-op is valid).
- The `block_row` fetch after the UPDATE uses the ALREADY-UPDATED schedule_blocks — this is fine because we only need task_id which didn't change.
- Do NOT import RegenerateDeltaRequest inline — add it to the existing imports from brain.schemas at the top of routes.py.
  </action>
  <verify>
    Start the server: `cd "/Users/eyalatar/Desktop/try /studyflow/backend" && python -c "from brain.routes import router; print('Import OK')" 2>&amp;1`
    Check for syntax errors: `python -m py_compile brain/routes.py brain/schemas.py 2>&amp;1`
    Verify endpoint registered: `python -c "from brain.routes import router; routes = [r.path for r in router.routes]; print([r for r in routes if 'delta' in r])"` should print `['/regenerate-delta']`
  </verify>
  <done>
    - POST /regenerate-delta route exists and imports without error
    - RegenerateDeltaRequest schema defined in brain/schemas.py
    - Route builds compressed snapshot, calls AI, parses delta, updates only FLX+A blocks
    - Returns {reasoning, blocks_updated, tasks, schedule} JSON response
    - FIX/M blocks excluded from updates at both Python and SQL level
  </done>
</task>

</tasks>

<verification>
1. `sqlite3 "/Users/eyalatar/Desktop/try /studyflow/studyflow.db" "PRAGMA table_info(schedule_blocks);" | grep manually` — shows is_manually_edited column
2. `cd "/Users/eyalatar/Desktop/try /studyflow/backend" && python -m py_compile server/database.py tasks/routes.py tasks/schemas.py brain/routes.py brain/schemas.py` — all compile without errors
3. `python -c "from brain.routes import router; print([r.path for r in router.routes])"` — `/regenerate-delta` in list
4. Start server and verify `curl -s http://localhost:8000/regenerate-delta` returns 405 (method not allowed on GET, meaning it exists as POST)
</verification>

<success_criteria>
- schedule_blocks.is_manually_edited column exists in DB (INTEGER DEFAULT 0)
- PATCH /tasks/block/{id} sets is_manually_edited=1 when time/title fields are provided
- POST /regenerate-delta endpoint returns 400 with "No upcoming schedule blocks found" when no schedule exists
- POST /regenerate-delta endpoint with a valid reason returns {reasoning, blocks_updated, tasks, schedule}
- No Python import or syntax errors in any modified file
</success_criteria>

<output>
After completion, create `.planning/phases/10-regenerate-roadmap/10-01-SUMMARY.md`
</output>
